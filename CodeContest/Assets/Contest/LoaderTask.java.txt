#define function=loadWorkspace
#define variable=LauncherConstant,LauncherSettings

private void loadWorkspace() {
    final Context context = mApp.getContext();
    final ContentResolver contentResolver = context.getContentResolver();
    final PackageManagerHelper pmHelper = new PackageManagerHelperCompat(context);
    final boolean isSafeMode = pmHelper.isSafeMode();
    final boolean isSdCardReady = Utilities.isBootCompleted();
    final MultiHashMap<UserHandle, String> pendingPackages = new MultiHashMap<>();

    boolean clearDb = false;
    SharedPreferences sp = Utilities.getPrefs(context);
    boolean isFirstRun = sp.getBoolean(LauncherConstant.IS_FIRST_RUN, true);
    if (isFirstRun) {
        Log.w(ImportOEMSettingsTask.TAG, "First run. UserId: " + context.getApplicationInfo().uid);
        try {
            if (!EnterpriseConfigManager.getInstance().isCoboDevice(context) && !WorkProfileUtils.isInWorkProfile(context)) {
                Log.w(ImportOEMSettingsTask.TAG, "performFactorySettingIfPossible. UserId: " + context.getApplicationInfo().uid);
                ImportOEMSettingsTask.performFactorySettingIfPossible(context);
            }
            sp.edit().putBoolean(LauncherConstant.IS_FIRST_RUN, false).commit();
        } catch (Exception e) {
            Log.e(ImportOEMSettingsTask.TAG, "config fails " + e.getMessage());
            clearDb = true;
            onDatabaseToBeWiped("ImportOEMSetting failure: " + e.getMessage());
        }
    } else {
        Log.w(ImportOEMSettingsTask.TAG, "Not first run config. UserId: " + context.getApplicationInfo().uid);
    }

    try {
        ImportDataTask.performImportIfPossible(context);
    } catch (Exception e) {
        // Migration failed. Clear workspace.
        clearDb = true;
        onDatabaseToBeWiped("ImportDataTask failure: " + e.getMessage());
    }

    if (!clearDb && GridSizeMigrationTask.ENABLED && !GridSizeMigrationTask.migrateGridIfNeeded(context)) {
        // Migration failed. Clear workspace.
        clearDb = true;
        onDatabaseToBeWiped("GridSizeMigration failure");
    }

    if (clearDb) {
        Log.d(TAG, "loadWorkspace: resetting launcher database");
        LauncherSettings.Settings.call(contentResolver,
                LauncherSettings.Settings.METHOD_CREATE_EMPTY_DB);
        onDatabaseWipeRequested();
    }
    if (!WorkProfileUtils.isInWorkProfile(context)) {
        Log.d(TAG, "loadWorkspace: loading default favorites");
        LauncherSettings.Settings.call(contentResolver,
                LauncherSettings.Settings.METHOD_LOAD_DEFAULT_FAVORITES);
    }
    if (ImportOEMSettingsTask.IS_ENABLE_PAI_OTA) {
        try {
            ImportOEMSettingsTask.importPAIConfigIfPossible(context, mBgDataModel);
        } catch (Exception e) {
            Log.e(ImportOEMSettingsTask.TAG, "Import PAI fails: " + e.getMessage());
        }
    }

    synchronized (mBgDataModel) {
        mBgDataModel.clear();

        final HashMap<PackageUserKey, SessionInfo> installingPkgs =
                mPackageInstaller.updateAndGetActiveSessionCache();
        final PackageUserKey tempPackageKey = new PackageUserKey(null, null);
        mFirstScreenBroadcast = new FirstScreenBroadcast(installingPkgs);
        mBgDataModel.workspaceScreens.addAll(LauncherModel.loadWorkspaceScreensDb(context));

        Map<ShortcutKey, ShortcutInfoCompat> shortcutKeyToPinnedShortcuts = new HashMap<>();
        Map<ShortcutKey, ShortcutInfoCompat> allShortcutKeyToPinnedShortcuts = new HashMap<>();
        final LoaderCursor c = new LoaderCursor(contentResolver.query(
                LauncherSettings.Favorites.CONTENT_URI, null, null, null, "modified DESC"), mApp);

        HashMap<ComponentKey, AppWidgetProviderInfo> widgetProvidersMap = null;
        List<WorkspaceItemInfo> appsets = new ArrayList<>();

        try {
            final int appWidgetIdIndex = c.getColumnIndexOrThrow(
                    LauncherSettings.Favorites.APPWIDGET_ID);
            final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
                    LauncherSettings.Favorites.APPWIDGET_PROVIDER);
            final int spanXIndex = c.getColumnIndexOrThrow
                    (LauncherSettings.Favorites.SPANX);
            final int spanYIndex = c.getColumnIndexOrThrow(
                    LauncherSettings.Favorites.SPANY);
            final int rankIndex = c.getColumnIndexOrThrow(
                    LauncherSettings.Favorites.RANK);
            final int optionsIndex = c.getColumnIndexOrThrow(
                    LauncherSettings.Favorites.OPTIONS);
            final int screenIndex = c.getColumnIndexOrThrow(
                    LauncherSettings.Favorites.SCREEN);
            final int appWidgetHasPaddingIndex = c.getColumnIndexOrThrow(
                    LauncherSettings.Favorites.APPWIDGET_HAS_PADDING);
            final int titleIndex = c.getColumnIndexOrThrow
                    (LauncherSettings.Favorites.TITLE);
            final int iconIndex = c.getColumnIndexOrThrow(
                    LauncherSettings.Favorites.ICON);
            final int behaviorIndex = c.getColumnIndexOrThrow(
                    LauncherSettings.Favorites.BEHAVIOR);
            final int referIdIndex = c.getColumnIndexOrThrow(
                    LauncherSettings.Favorites.REFER_ID);
            final int intentIndex = c.getColumnIndexOrThrow
                    (LauncherSettings.Favorites.INTENT);
            final int swipeUpToOpenIndex = c.getColumnIndexOrThrow(
                    LauncherSettings.Favorites.SWIPE_UP_TO_OPEN);

            final LongSparseArray<UserHandle> allUsers = c.allUsers;
            final LongSparseArray<Boolean> quietMode = new LongSparseArray<>();
            final LongSparseArray<Boolean> unlockedUsers = new LongSparseArray<>();
            for (UserHandle user : mUserManager.getUserProfiles()) {
                long serialNo = mUserManager.getSerialNumberForUser(user);
                allUsers.put(serialNo, user);
                quietMode.put(serialNo, mUserManager.isQuietModeEnabled(user));

                boolean userUnlocked = mUserManager.isUserUnlocked(user);

                // We can only query for shortcuts when the user is unlocked.
                if (userUnlocked) {
                    DeepShortcutManager.QueryResult pinnedShortcuts =
                            mShortcutManager.queryForPinnedShortcuts(null, user);
                    if (pinnedShortcuts.wasSuccess()) {
                        for (ShortcutInfoCompat shortcut : pinnedShortcuts) {
                            shortcutKeyToPinnedShortcuts.put(ShortcutKey.fromInfo(shortcut),
                                    shortcut);
                        }
                    } else {
                        // Shortcut manager can fail due to some race condition when the
                        // lock state changes too frequently. For the purpose of the loading
                        // shortcuts, consider the user is still locked.
                        userUnlocked = false;
                    }
                    List<ShortcutInfoCompat> allPinnedShortcuts =
                            mShortcutManager.queryForAllShortcuts(user);
                    if (mShortcutManager.wasLastCallSuccess()) {
                        for (ShortcutInfoCompat shortcut : allPinnedShortcuts) {
                            allShortcutKeyToPinnedShortcuts.put(ShortcutKey.fromInfo(shortcut),
                                    shortcut);
                        }
                    } else {
                        userUnlocked = false;
                    }
                }
                unlockedUsers.put(serialNo, userUnlocked);
            }

            WorkspaceItemInfo info;
            LauncherAppWidgetInfo appWidgetInfo;
            FeaturePageInfo featurePageInfo;
            Intent intent;
            String targetPkg;
            IFeatureManager featureManager = FeatureManager.getInstance();
            ComponentName weatherActivityComponentName = new ComponentName(context, WeatherActivity.class);
            boolean isWeatherAppIconEnabled = featureManager.isFeatureEnabled(WEATHER_APP_ICON);

            while (!mStopped && c.moveToNext()) {
                try {
                    if (c.user == null) {
                        // User has been deleted, remove the item.
                        c.markDeleted("User has been deleted");
                        continue;
                    }

                    boolean allowMissingTarget = false;
                    switch (c.itemType) {
                        case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
                        case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
                        case LauncherSettings.Favorites.ITEM_TYPE_DEEP_SHORTCUT:
                        case LauncherSettings.Favorites.ITEM_TYPE_APPSET:
                            intent = c.parseIntent();
                            if (intent == null) {
                                c.markDeleted("Invalid or null intent");
                                continue;
                            }

                            // TODO: remove this as it is Preview build only
                            //       remove Weather app icon
                            if (!isWeatherAppIconEnabled
                                    && c.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT
                                    && weatherActivityComponentName.equals(intent.getComponent())) {
                                c.markDeleted("Disable weather app icon");
                                continue;
                            }

                            Intent secondIntent = null;
                            if (c.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPSET) {
                                secondIntent = c.parseSecondIntent();
                                if (secondIntent == null) {
                                    continue;
                                }
                            }

                            int disabledState = quietMode.get(c.serialNumber) ?
                                    WorkspaceItemInfo.FLAG_DISABLED_QUIET_USER : 0;
                            ComponentName cn = intent.getComponent();
                            targetPkg = cn == null ? intent.getPackage() : cn.getPackageName();

                            if (allUsers.indexOfValue(c.user) < 0) {
                                if (c.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
                                    c.markDeleted("Legacy shortcuts are only allowed for current users");
                                    continue;
                                } else if (c.restoreFlag != 0) {
                                    // Don't restore items for other profiles.
                                    c.markDeleted("Restore from other profiles not supported");
                                    continue;
                                }
                            }
                            if (TextUtils.isEmpty(targetPkg) &&
                                    c.itemType != LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
                                c.markDeleted("Only legacy shortcuts can have null package");
                                continue;
                            }

                            // If there is no target package, its an implicit intent
                            // (legacy shortcut) which is always valid
                            boolean validTarget = mLauncherApps.isPackageEnabledForProfile(targetPkg, c.user, intent);

                            // If it's a deep shortcut, we'll use pinned shortcuts to restore it
                            if (cn != null && validTarget && c.itemType
                                    != LauncherSettings.Favorites.ITEM_TYPE_DEEP_SHORTCUT) {
                                // If the apk is present and the shortcut points to a specific
                                // component.

                                // If the component is already present
                                if (mLauncherApps.isActivityEnabledForProfile(cn, c.user)) {
                                    // no special handling necessary for this item
                                    c.markRestored();
                                } else {
                                    // Gracefully try to find a fallback activity.
                                    intent = pmHelper.getAppLaunchIntent(targetPkg, c.user);
                                    if (intent != null) {
                                        c.restoreFlag = 0;
                                        c.updater().put(
                                                LauncherSettings.Favorites.INTENT,
                                                intent.toUri(0)).commit();
                                        cn = intent.getComponent();
                                    } else {
                                        c.markDeleted("Unable to find a launch target");
                                        continue;
                                    }
                                }
                            }
                            // else if cn == null => can't infer much, leave it
                            // else if !validPkg => could be restored icon or missing sd-card

                            if (!TextUtils.isEmpty(targetPkg) && !validTarget) {
                                // Points to a valid app (superset of cn != null) but the apk
                                // is not available.

                                if (c.restoreFlag != 0) {
                                    // Package is not yet available but might be
                                    // installed later.
                                    FileLog.d(TAG, "package not yet restored: " + targetPkg);

                                    tempPackageKey.update(targetPkg, c.user);
                                    if (c.hasRestoreFlag(WorkspaceItemInfo.FLAG_RESTORE_STARTED)) {
                                        // Restore has started once.
                                    } else {
                                        // App restore has started. Update the flag
                                        c.restoreFlag |= WorkspaceItemInfo.FLAG_RESTORE_STARTED;
                                        c.updater().put(LauncherSettings.Favorites.RESTORED,
                                                c.restoreFlag).commit();
                                    }
                                } else if (pmHelper.isAppOnSdcard(targetPkg, c.user)) {
                                    // Package is present but not available.
                                    disabledState |= WorkspaceItemInfo.FLAG_DISABLED_NOT_AVAILABLE;
                                    // Add the icon on the workspace anyway.
                                    allowMissingTarget = true;
                                } else if (!isSdCardReady) {
                                    // SdCard is not ready yet. Package might get available,
                                    // once it is ready.
                                    Log.d(TAG, "Missing pkg, will check later: " + targetPkg);
                                    pendingPackages.addToList(c.user, targetPkg);
                                    // Add the icon on the workspace anyway.
                                    allowMissingTarget = true;
                                } else if (SystemUtils.isOPPODevice()
                                        && cn != null
                                        && mLauncherApps.isActivityEnabledForProfile(cn, c.user)) {
                                    // for some oppo device, a package may be queried as disabled
                                    // but its icon will show in the app drawer
                                    // once we launch the app, the package would be updated enabled
                                    // so, we prefer not the delete this icon
                                    Log.d(TAG, "Oppo disabled pkg, the pkg might be enabled after being launched: " + targetPkg);
                                } else {
                                    // Do not wait for external media load anymore.
                                    c.markDeleted("Invalid package removed: " + targetPkg);
                                    continue;
                                }
                            }

                            if ((c.restoreFlag & WorkspaceItemInfo.FLAG_SUPPORTS_WEB_UI) != 0) {
                                validTarget = false;
                            }

                            if (validTarget) {
                                // The shortcut points to a valid target (either no target
                                // or something which is ready to be used)
                                c.markRestored();
                            }

                            boolean useLowResIcon = !c.isOnWorkspaceOrHotseat();

                            if (c.restoreFlag != 0) {
                                // Already verified above that user is same as default user
                                info = c.getRestoredItemInfo(intent);
                            } else if (c.itemType ==
                                    LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
                                info = c.getAppShortcutInfo(
                                        intent, allowMissingTarget, useLowResIcon);
                            } else if (c.itemType ==
                                    LauncherSettings.Favorites.ITEM_TYPE_DEEP_SHORTCUT
                                    || (c.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT
                                    && intent.getCategories() != null
                                    && intent.getCategories().contains(LauncherSettings.Favorites.INTENT_CATEGORY_DEEP_SHORTCUT))) {

                                ShortcutKey key = ShortcutKey.fromIntent(intent, c.user);
                                if (unlockedUsers.get(c.serialNumber)) {
                                    ShortcutInfoCompat pinnedShortcut =
                                            shortcutKeyToPinnedShortcuts.get(key);
                                    if (pinnedShortcut == null) {
                                        // The deep shortcuts pinned by v5 launcher are not in the shortcutKeyToPinnedShortcuts
                                        // So try to find it in all shortcut.
                                        pinnedShortcut = allShortcutKeyToPinnedShortcuts.get(key);
                                        if (pinnedShortcut == null) {
                                            // The shortcut is no longer valid.
                                            c.markDeleted("Pinned shortcut not found");
                                            continue;
                                        }
                                    }
                                    info = new WorkspaceItemInfo(pinnedShortcut, context);
                                    final WorkspaceItemInfo finalInfo = info;

                                    LauncherIcons li = LauncherIcons.obtain(context);
                                    // If the pinned deep shortcut is no longer published,
                                    // use the last saved icon instead of the default.
                                    Supplier<ItemInfoWithIcon> fallbackIconProvider = () ->
                                            c.loadIcon(finalInfo, li) ? finalInfo : null;
                                    info.applyFrom(li.createShortcutIcon(pinnedShortcut,
                                            true /* badged */, fallbackIconProvider));
                                    li.recycle();
                                    if (pmHelper.isAppSuspended(
                                            pinnedShortcut.getPackage(), info.user)) {
                                        info.runtimeStatusFlags |= FLAG_DISABLED_SUSPENDED;
                                    }
                                    intent = info.intent;
                                } else {
                                    // Create a shortcut info in disabled mode for now.
                                    info = c.loadSimpleWorkspaceItem();
                                    info.runtimeStatusFlags |= FLAG_DISABLED_LOCKED_USER;
                                }
                            } else { // item type == ITEM_TYPE_SHORTCUT
                                if (IconUtils.isWebLinkShortcut(intent)) {
                                    info = c.loadWebLinkShortcut(intent);
                                } else {
                                    info = c.loadSimpleWorkspaceItem();
                                    if (context.getPackageName().equals(targetPkg)) {
                                        c.loadTitleForLauncherShortcut(info, intent);
                                    }
                                }

                                // Shortcuts are only available on the primary profile
                                if (!TextUtils.isEmpty(targetPkg)
                                        && pmHelper.isAppSuspended(targetPkg, c.user)) {
                                    disabledState |= FLAG_DISABLED_SUSPENDED;
                                }

                                // App shortcuts that used to be automatically added to Launcher
                                // didn't always have the correct intent flags set, so do that
                                // here
                                if (intent.getAction() != null &&
                                        intent.getCategories() != null &&
                                        intent.getAction().equals(Intent.ACTION_MAIN) &&
                                        intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
                                    intent.addFlags(
                                            Intent.FLAG_ACTIVITY_NEW_TASK |
                                                    Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
                                }
                            }

                            if (info != null) {
                                c.applyCommonProperties(info);

                                info.intent = intent;
                                info.secondIntent = secondIntent;
                                info.rank = c.getInt(rankIndex);
                                info.spanX = c.getInt(spanXIndex);
                                info.spanY = c.getInt(spanYIndex);
                                info.runtimeStatusFlags |= disabledState;
                                if (isSafeMode && !isSystemApp(context, intent)) {
                                    info.runtimeStatusFlags |= FLAG_DISABLED_SAFEMODE;
                                }

                                if (c.restoreFlag != 0 && !TextUtils.isEmpty(targetPkg)) {
                                    tempPackageKey.update(targetPkg, c.user);
                                    SessionInfo si = installingPkgs.get(tempPackageKey);
                                    if (si == null) {
                                        info.status &= ~WorkspaceItemInfo.FLAG_INSTALL_SESSION_ACTIVE;
                                    } else {
                                        info.setInstallProgress((int) (si.getProgress() * 100));
                                    }
                                }
                                info.behaviorStr = c.getString(behaviorIndex);
                                if (info.behaviorStr == null) {
                                    info.behaviorStr = new ActionItem(ActionItem.LAUNCHER_TYPE, ActionItem.ACTION_NONE).toString();
                                }
                                c.checkAndAddItem(info, mBgDataModel);
                                if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPSET) {
                                    appsets.add(info);
                                }
                            } else {
                                throw new RuntimeException("Unexpected null WorkspaceItemInfo");
                            }
                            break;

                        case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
                            FolderInfo folderInfo = mBgDataModel.findOrMakeFolder(c.id);
                            c.applyCommonProperties(folderInfo);

                            // Do not trim the folder label, as is was set by the user.
                            folderInfo.title = c.getString(c.titleIndex);
                            folderInfo.spanX = c.getInt(spanXIndex);
                            folderInfo.spanY = c.getInt(spanYIndex);
                            folderInfo.options = c.getInt(optionsIndex);
                            folderInfo.behaviorStr = c.getString(behaviorIndex);
                            if (folderInfo.behaviorStr == null) {
                                folderInfo.behaviorStr = new ActionItem(ActionItem.LAUNCHER_TYPE, ActionItem.ACTION_NONE).toString();
                            }
                            folderInfo.swipeUpToOpen = c.getInt(swipeUpToOpenIndex);
                            folderInfo.iconBitmap = getIconFromCursor(c, iconIndex, context);


                            // no special handling required for restored folders
                            c.markRestored();

                            c.checkAndAddItem(folderInfo, mBgDataModel);
                            break;

                        case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
                            if (FeatureFlags.GO_DISABLE_WIDGETS) {
                                c.markDeleted("Only legacy shortcuts can have null package");
                                continue;
                            }
                            // Follow through
                        case LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET:
                            if (c.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
                                c.markDeleted("Restore data from earlier version");
                                continue;
                            }

                            // Read all Launcher-specific widget details
                            boolean customWidget = c.itemType ==
                                    LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET;

                            int appWidgetId = c.getInt(appWidgetIdIndex);
                            String savedProvider = c.getString(appWidgetProviderIndex);
                            final ComponentName component;

                            boolean isSearchWidget = (c.getInt(optionsIndex)
                                    & LauncherAppWidgetInfo.OPTION_SEARCH_WIDGET) != 0;
                            if (isSearchWidget) {
                                component  = QsbContainerView.getSearchComponentName(context);
                                if (component == null) {
                                    c.markDeleted("Discarding SearchWidget without packagename ");
                                    continue;
                                }
                            } else {
                                component = ComponentName.unflattenFromString(savedProvider);
                            }
                            final boolean isIdValid = !c.hasRestoreFlag(
                                    LauncherAppWidgetInfo.FLAG_ID_NOT_VALID);
                            final boolean wasProviderReady = !c.hasRestoreFlag(
                                    LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY);

                            if (widgetProvidersMap == null) {
                                widgetProvidersMap = mAppWidgetManager.getAllProvidersMap();
                            }
                            final AppWidgetProviderInfo provider = widgetProvidersMap.get(
                                    new ComponentKey(component, c.user));

                            final boolean isProviderReady = isValidProvider(provider);
                            if (!isSafeMode && !customWidget &&
                                    wasProviderReady && !isProviderReady) {
                                c.markDeleted(
                                        "Deleting widget that isn't installed anymore: "
                                                + provider);
                                if (c.container == LauncherSettings.Favorites.CONTAINER_NAVIGATION_PAGE) {
                                    NavigationManager.getInstance(context).markWidgetCardDeleted(context, appWidgetId);
                                }

                            } else {
                                if (isProviderReady) {
                                    appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
                                            provider);

                                    // The provider is available. So the widget is either
                                    // available or not available. We do not need to track
                                    // any future restore updates.
                                    int status = c.restoreFlag &
                                            ~LauncherAppWidgetInfo.FLAG_RESTORE_STARTED &
                                            ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY;
                                    if (!wasProviderReady) {
                                        // If provider was not previously ready, update the
                                        // status and UI flag.

                                        // Id would be valid only if the widget restore broadcast was received.
                                        if (isIdValid) {
                                            status |= LauncherAppWidgetInfo.FLAG_UI_NOT_READY;
                                        }
                                    }
                                    appWidgetInfo.restoreStatus = status;
                                } else {
                                    Log.v(TAG, "Widget restore pending id=" + c.id
                                            + " appWidgetId=" + appWidgetId
                                            + " status =" + c.restoreFlag);
                                    if (c.itemType ==
                                            LauncherSettings.Favorites.ITEM_TYPE_CUSTOM_APPWIDGET) {
                                        // Unsupported private widget, might be restored form
                                        // a higher version.
                                        c.markDeleted("Unsupported private widget removed: " + component);
                                        continue;
                                    }

                                    appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
                                            component);
                                    appWidgetInfo.restoreStatus = c.restoreFlag;

                                    tempPackageKey.update(component.getPackageName(), c.user);
                                    SessionInfo si =
                                            installingPkgs.get(tempPackageKey);
                                    Integer installProgress = si == null
                                            ? null
                                            : (int) (si.getProgress() * 100);

                                    if (c.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_RESTORE_STARTED)) {
                                        // Restore has started once.
                                    } else if (installProgress != null) {
                                        // App restore has started. Update the flag
                                        appWidgetInfo.restoreStatus |=
                                                LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
                                    } else if (!isSafeMode) {
                                        c.markDeleted("Unrestored widget removed: " + component);
                                        continue;
                                    }

                                    appWidgetInfo.installProgress =
                                            installProgress == null ? 0 : installProgress;
                                }
                                if (appWidgetInfo.hasRestoreFlag(
                                        LauncherAppWidgetInfo.FLAG_DIRECT_CONFIG) || customWidget) {
                                    appWidgetInfo.bindOptions = c.parseIntent();
                                }

                                c.applyCommonProperties(appWidgetInfo);
                                appWidgetInfo.spanX = c.getInt(spanXIndex);
                                appWidgetInfo.spanY = c.getInt(spanYIndex);
                                appWidgetInfo.options = c.getInt(optionsIndex);
                                appWidgetInfo.user = c.user;
                                appWidgetInfo.hasPadding = c.getInt(appWidgetHasPaddingIndex);

                                if (appWidgetInfo.spanX <= 0 || appWidgetInfo.spanY <= 0) {
                                    c.markDeleted("Widget has invalid size: "
                                            + appWidgetInfo.spanX + "x" + appWidgetInfo.spanY);
                                    continue;
                                }
                                if (!c.isOnWorkspaceOrHotseatOrNavigationPage()) {
                                    c.markDeleted("Widget found where container != " +
                                            "CONTAINER_DESKTOP nor CONTAINER_HOTSEAT nor CONTAINER_NAVIGATION_PAGE - ignoring!");
                                    continue;
                                }
                                if (!customWidget) {
                                    String providerName =
                                            appWidgetInfo.providerName.flattenToString();
                                    if (!providerName.equals(savedProvider) ||
                                            (appWidgetInfo.restoreStatus != c.restoreFlag)) {
                                        c.updater()
                                                .put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
                                                        providerName)
                                                .put(LauncherSettings.Favorites.RESTORED,
                                                        appWidgetInfo.restoreStatus)
                                                .commit();
                                    }
                                }

                                if (appWidgetInfo.restoreStatus !=
                                        LauncherAppWidgetInfo.RESTORE_COMPLETED) {
                                    String pkg = appWidgetInfo.providerName.getPackageName();
                                    appWidgetInfo.pendingItemInfo = new PackageItemInfo(pkg);
                                    appWidgetInfo.pendingItemInfo.user = appWidgetInfo.user;
                                    mIconCache.getTitleAndIconForApp(
                                            appWidgetInfo.pendingItemInfo, false);
                                }

                                // remove custom widgets if they are not enabled
                                // TODO: (hongyang) consider to add a util method to convert appWidgetId into providerId?
                                if (customWidget
                                        && !CustomWidgetFeatureController.getInstance().isWidgetEnabled(context, CUSTOM_WIDGET_ID - appWidgetInfo.appWidgetId, true)) {
                                    c.markDeleted("Disable widget in preview builds");
                                    continue;
                                }
                                c.checkAndAddItem(appWidgetInfo, mBgDataModel);
                            }
                            break;
                        case LauncherSettings.Favorites.ITEM_TYPE_FEATURE_PAGE:
                            int featurePageId = c.getInt(appWidgetIdIndex);
                            int screenId = c.getInt(screenIndex);
                            if (!mBgDataModel.workspaceScreens.contains(screenId)) {
                                c.markDeleted("Screen ID " + screenId + " is not exist.");
                                continue;
                            }
                            String featurePageProvider = c.getString(appWidgetProviderIndex);

                            final ComponentName pageComponent = ComponentName.unflattenFromString(featurePageProvider);
                            featurePageInfo = new FeaturePageInfo(featurePageId, pageComponent);
                            c.applyCommonProperties(featurePageInfo);
                            c.checkAndAddItem(featurePageInfo, mBgDataModel);
                            break;
                        case LauncherSettings.Favorites.ITEM_TYPE_EDIT_RESULT:
                            AppEditInfo editInfo = new AppEditInfo();
                            editInfo.title = c.getString(titleIndex);
                            c.applyCommonProperties(editInfo);

                            try {
                                editInfo.iconBitmap = getIconFromCursor(c, iconIndex, context);
                            } catch (Exception e) {
                                Log.d("createBitmap", e.getMessage());
                            }
                            editInfo.user = c.user;
                            if (c.getString(intentIndex) != null) {
                                editInfo.intent = Intent.parseUri(c.getString(intentIndex), 0);
                            }
                            editInfo.referId = c.getLong(referIdIndex);
                            if (editInfo.container == -1) {
                                editInfo.container = LauncherSettings.Favorites.CONTAINER_DESKTOP;
                            }

                            mBgDataModel.addOrUpdateEditInfoInternal(editInfo);
                            break;
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Desktop items loading interrupted", e);
                }
            }

        } finally {
            IOUtils.closeSilently(c);
        }

        // Break early if we've stopped loading
        if (mStopped) {
            mBgDataModel.clear();
            return;
        }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            for (WorkspaceItemInfo appset : appsets) {
                try {
                    appset.iconBitmap = new AppSetInfo(appset).generateBitmap(false);
                    AppSetUtils.generateShadowForShortcut(appset, context);
                } catch (AppSetInfo.AppsetIllegalStateException e) {
                    // This appset goes into an incorrect state. Probably by a crash while creating app sets.
                    // Clear the app set info in load task.
                    c.markDeleted(appset.id, "Incorrect appset state");
                    mBgDataModel.workspaceItems.remove(appset);
                    mBgDataModel.appSets.remove(appset);
                    mBgDataModel.itemsIdMap.remove(appset.id);
                    HashSet<ItemInfo> itemInfos =
                            ItemInfoMatcher.ofItemContainer(appset.id).filterItemInfos(mBgDataModel.itemsIdMap);
                    if (itemInfos != null) {
                        for (ItemInfo itemInfo : itemInfos) {
                            c.markDeleted(itemInfo.id, "Incorrect appset child state");
                            mBgDataModel.workspaceItems.remove(itemInfo);
                            mBgDataModel.itemsIdMap.remove(appset.id);
                        }
                    }
                }
            }
        }

        // Remove dead items
        if (c.commitDeleted()) {
            // Remove any empty folder
            int[] deletedFolderIds = LauncherSettings.Settings
                    .call(contentResolver,
                            LauncherSettings.Settings.METHOD_DELETE_EMPTY_FOLDERS)
                    .getIntArray(LauncherSettings.Settings.EXTRA_VALUE);
            for (int folderId : deletedFolderIds) {
                mBgDataModel.workspaceItems.remove(mBgDataModel.folders.get(folderId));
                mBgDataModel.folders.remove(folderId);
                mBgDataModel.itemsIdMap.remove(folderId);
            }

            // Remove any ghost widgets
            LauncherSettings.Settings.call(contentResolver,
                    LauncherSettings.Settings.METHOD_REMOVE_GHOST_WIDGETS);
            NavigationManager.getInstance(context).removeGhostCards(context);
        }

        // Update some widget spanXY values
        c.commitUpdated();

        // Unpin shortcuts that don't exist on the workspace.
        HashSet<ShortcutKey> pendingShortcuts =
                InstallShortcutReceiver.getPendingShortcuts(context);
        for (ShortcutKey key : shortcutKeyToPinnedShortcuts.keySet()) {
            MutableInt numTimesPinned = mBgDataModel.pinnedShortcutCounts.get(key);
            if ((numTimesPinned == null || numTimesPinned.value == 0)
                    && !pendingShortcuts.contains(key)) {
                // Shortcut is pinned but doesn't exist on the workspace; unpin it.
                mShortcutManager.unpinShortcut(key);
            }
        }

        boolean isPopup = !AppStatusUtils.getBoolean(context, AppStatusUtils.PREFERENCE_NAME_FOR_SETTINGS, com.microsoft.launcher.setting.Constants.FOLDER_FULLSCREEN_KEY,
                com.microsoft.launcher.setting.Constants.FOLDER_FULLSCREEN_DEFAULT_VALUE);
        // Sort the folder items, update ranks, and make sure all preview items are high res.
        FolderGridOrganizer verifier = UiFactory.createFolderGridOrganizer(mApp.getInvariantDeviceProfile(), isPopup);
        for (FolderInfo folder : mBgDataModel.folders) {
            folder.sortContents(Folder.ITEM_POS_COMPARATOR);
            verifier.setFolderInfo(folder);
            int size = folder.contents.size();

            // Update ranks here to ensure there are no gaps caused by removed folder items.
            // Ranks are the source of truth for folder items, so cellX and cellY can be ignored
            // for now. Database will be updated once user manually modifies folder.
            for (int rank = 0; rank < size; ++rank) {
                WorkspaceItemInfo info = folder.contents.get(rank);
                info.rank = rank;

                if (info.usingLowResIcon()
                        && info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION
                        && verifier.isItemInPreview(info.rank)) {
                    mIconCache.getTitleAndIcon(info, false);
                }
            }
        }

        c.commitRestoredItems();
        if (!isSdCardReady && !pendingPackages.isEmpty()) {
            context.registerReceiver(
                    new SdCardAvailableReceiver(mApp, pendingPackages),
                    new IntentFilter(Intent.ACTION_BOOT_COMPLETED),
                    null,
                    MODEL_EXECUTOR.getHandler());
        }

        // Remove any empty screens
        IntArray unusedScreens = mBgDataModel.workspaceScreens.clone();
        for (ItemInfo item: mBgDataModel.itemsIdMap) {
            int screenId = item.screenId;
            if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &&
                    unusedScreens.contains(screenId)) {
                unusedScreens.removeValue(screenId);
            }
        }
    }
}